{"version":3,"file":"cache.js","sourceRoot":"","sources":["../../../src/lib/styles/cache.ts"],"names":[],"mappings":";;;AA2BA;;;;GAIG;AACH,MAAa,KAAK;IAChB,YACqB,KAAQ,EAClB,SAAkB;QADR,UAAK,GAAL,KAAK,CAAG;QAClB,cAAS,GAAT,SAAS,CAAS;IAC1B,CAAC;IAEJ;;;;OAIG;IACO,aAAa,CAAC,GAAW;QACjC,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,OAAO,GAAG,IAAI,CAAC,SAAS,IAAI,GAAG,EAAE,CAAC;QACpC,CAAC;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,WAAW,CAAC,GAAW,EAAE,OAA6B;QAC1D,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;QAC9C,IAAI,KAAK,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QAEhD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;YACxB,KAAK,GAAG,MAAM,OAAO,EAAE,CAAC;YACxB,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;QAC7C,CAAC;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,GAAG,CAAC,GAAW;QACnB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;QAE5D,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,GAAG,CAAC,GAAW,EAAE,KAAQ;QAC7B,MAAM,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;IACvD,CAAC;CACF;AA3DD,sBA2DC;AAED;;GAEG;AACH,MAAa,WAAe,SAAQ,KAAwB;IAC1D;QACE,KAAK,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC;IACnB,CAAC;IAED;;OAEG;IACH,KAAK;QACH,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IACrB,CAAC;IAED;;;OAGG;IACH,MAAM;QACJ,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;IAC7B,CAAC;IAED;;;OAGG;IACH,OAAO;QACL,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;IAC9B,CAAC;CACF;AA3BD,kCA2BC","sourcesContent":["/**\n * A backing data store for one or more Cache instances.\n * The interface is intentionally designed to support using a JavaScript\n * Map instance as a potential cache store.\n */\nexport interface CacheStore<V> {\n  /**\n   * Returns the specified value from the cache store or `undefined` if not found.\n   * @param key The key to retrieve from the store.\n   */\n  get(key: string): V | undefined | Promise<V | undefined>;\n\n  /**\n   * Returns whether the provided key is present in the cache store.\n   * @param key The key to check from the store.\n   */\n  has(key: string): boolean | Promise<boolean>;\n\n  /**\n   * Adds a new value to the cache store if the key is not present.\n   * Updates the value for the key if already present.\n   * @param key The key to associate with the value in the cache store.\n   * @param value The value to add to the cache store.\n   */\n  set(key: string, value: V): this | Promise<this>;\n}\n\n/**\n * A cache object that allows accessing and storing key/value pairs in\n * an underlying CacheStore. This class is the primary method for consumers\n * to use a cache.\n */\nexport class Cache<V, S extends CacheStore<V> = CacheStore<V>> {\n  constructor(\n    protected readonly store: S,\n    readonly namespace?: string,\n  ) {}\n\n  /**\n   * Prefixes a key with the cache namespace if present.\n   * @param key A key string to prefix.\n   * @returns A prefixed key if a namespace is present. Otherwise the provided key.\n   */\n  protected withNamespace(key: string): string {\n    if (this.namespace) {\n      return `${this.namespace}:${key}`;\n    }\n\n    return key;\n  }\n\n  /**\n   * Gets the value associated with a provided key if available.\n   * Otherwise, creates a value using the factory creator function, puts the value\n   * in the cache, and returns the new value.\n   * @param key A key associated with the value.\n   * @param creator A factory function for the value if no value is present.\n   * @returns A value associated with the provided key.\n   */\n  async getOrCreate(key: string, creator: () => V | Promise<V>): Promise<V> {\n    const namespacedKey = this.withNamespace(key);\n    let value = await this.store.get(namespacedKey);\n\n    if (value === undefined) {\n      value = await creator();\n      await this.store.set(namespacedKey, value);\n    }\n\n    return value;\n  }\n\n  /**\n   * Gets the value associated with a provided key if available.\n   * @param key A key associated with the value.\n   * @returns A value associated with the provided key if present. Otherwise, `undefined`.\n   */\n  async get(key: string): Promise<V | undefined> {\n    const value = await this.store.get(this.withNamespace(key));\n\n    return value;\n  }\n\n  /**\n   * Puts a value in the cache and associates it with the provided key.\n   * If the key is already present, the value is updated instead.\n   * @param key A key associated with the value.\n   * @param value A value to put in the cache.\n   */\n  async put(key: string, value: V): Promise<void> {\n    await this.store.set(this.withNamespace(key), value);\n  }\n}\n\n/**\n * A lightweight in-memory cache implementation based on a JavaScript Map object.\n */\nexport class MemoryCache<V> extends Cache<V, Map<string, V>> {\n  constructor() {\n    super(new Map());\n  }\n\n  /**\n   * Removes all entries from the cache instance.\n   */\n  clear() {\n    this.store.clear();\n  }\n\n  /**\n   * Provides all the values currently present in the cache instance.\n   * @returns An iterable of all values in the cache.\n   */\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Provides all the keys/values currently present in the cache instance.\n   * @returns An iterable of all key/value pairs in the cache.\n   */\n  entries() {\n    return this.store.entries();\n  }\n}\n"]}